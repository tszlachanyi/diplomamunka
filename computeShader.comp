#version 460 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 1, r32ui) readonly uniform uimage2D inputImage;
layout (binding = 2, r32ui) writeonly uniform uimage2D outputImage;

uint[4][4][3] allRules =
{
   {{0,1,15-1} , {1,0,15-1} , {0,-1,15-1}, {-1,0,15-1}},
   {{0,1,15-2} , {1,0,15-2} , {0,-1,15-2}, {-1,0,15-2}},
   {{0,1,15-4} , {1,0,15-4} , {0,-1,15-4}, {-1,0,15-4}},
   {{0,1,15-8} , {1,0,15-8} , {0,-1,15-8}, {-1,0,15-8}},
};

uint rulesAmount = 4;
uint rules[4][3];

uniform uint userChosenValue;
uniform ivec2 userChosenCoords;
uniform float random1;
uniform float random2;
uniform uint TILE_VALUES;

const uint MAXIMUM_TILE_VALUES = 32;
uint cellValue;
uint chosenCellOldValue;
uint chosenCellIndex;
uint[MAXIMUM_TILE_VALUES] tileArray;
uint entropy;

ivec2 chosenCoords; // Cell choosen to get collapsed
ivec2 currentCoords; // Current cell

layout(binding = 0) uniform atomic_uint minCounter;
layout(binding = 1) buffer ssbo
{
    ivec2 minEntropyCells[];
};
layout(binding = 2) uniform atomic_uint minEntropyCellsAmount;

uint nthBit(uint number, uint n)
{
	return (number >> n) & 1;
}

// All different tiles the cell can be currently		entropy is the size of this vector
void possibleTiles(in uint number, out uint[MAXIMUM_TILE_VALUES] tileArray, out uint entropy)
{
	entropy = 0;

	for (int i = 0; i < TILE_VALUES; i++)
	{
		if (nthBit(number, i) == 1)
		{
			tileArray[entropy]= i;
			entropy += 1;
		}
	}
}

void main()
{
	// Current Value
	currentCoords = ivec2(gl_GlobalInvocationID.xy);
	cellValue = imageLoad(inputImage, currentCoords)[0];

	// Chosen Cell
	chosenCellIndex = uint(floor(random1 * atomicCounter(minEntropyCellsAmount)));
	chosenCoords = minEntropyCells[chosenCellIndex];

	// Chosen Value
	chosenCellOldValue = imageLoad(inputImage, chosenCoords)[0];
	possibleTiles(chosenCellOldValue, tileArray, entropy);
	uint chosenTileIndex = tileArray[uint(floor(random2 * entropy))];
	uint chosenValue = uint(pow(2, chosenTileIndex));

	rules = allRules[chosenTileIndex];

	// Calculate output value
	if (currentCoords == chosenCoords)		// Give the chosen value to the chosen cell
	{		
		if (userChosenValue != 0)
		{
			cellValue = userChosenValue;
		}
		else
		{
			cellValue = chosenValue;
		}
	}
	else	// Use rules on other cells
	{
		for (int i = 0; i < rulesAmount; i++)
		{
			if (currentCoords == chosenCoords + ivec2(rules[i][0], rules[i][1]))
			{
				cellValue = cellValue &  rules[i][2];
			}
		}
	}

	imageStore(outputImage, currentCoords, uvec4(cellValue, 0u, 0u, 0u));

}